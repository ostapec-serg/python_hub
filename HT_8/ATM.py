import jsonfrom itertools import combinations_with_replacementimport user_funcdef atm_cash():    all_cash = []    change_banknote = {}    bank = remainder()    banknote = bank    for row in banknote:        change_banknote.update(row)    for line in change_banknote.items():        result = int(line[0]) * int(line[1])        all_cash.append(result)    return sum(all_cash)def remainder():    with open("Banknote.data.json", "r",              encoding="utf-8") as file:        old_cash = json.load(file)        return [old_cash]def note_amount():    up_atm = {}    print(('Порядок ввода.\n'           'В первой строке - Введите номинал банкноты - '           'вводиться номинал 1й купюры.\n В '           'строке - Введите количество банкнот - '           'вводиться количество купюр\n'           'введенных в строке - Введите номинал банкноты -\n'           '\n'           'Список банкнот в наявности в банкомате:\n'))    print(balance_banknotes())    while True:        try:            print("Для подтверждения 0\n")            banknote = abs(int(input("Введите номинал банкноты(целое число):\n"                                     "Для выхода введите 0\n")))            if (banknote == 10 or banknote == 20 or banknote == 50 or                    banknote == 100 or banknote == 200 or banknote == 500 or                    banknote == 1000 or banknote == 0):                if banknote != 0:                    amount = abs(int(input("Введите количество банкнот:(целое число)\n")))                    up_atm[banknote] = amount                else:                    return up_atm            else:                print("Не верный номинал банкнот!\n"                      "Допустимые номиналы:\n"                      "10, 20, 50, 100, 200, 500, 1000")        except Exception:            print("Не верное количество банкнот!")def balance_banknotes():    all_cash = []    change_banknote = {}    banknote = remainder()    for row in banknote:        change_banknote.update(row)    for line in change_banknote.items():        result = int(line[0]) * int(line[1])        all_cash.append(result)        print(f"Номинал {line[0]} = {line[1]} купюр")    return f"Купюр ка сумму {atm_cash()} USD\n"def banknote_write(new):    transaction = json.dumps(new)    transaction = json.loads(str(transaction))    with open("Banknote.data.json", "w", encoding="utf-8") as file:        json.dump(transaction, file, indent=2, sort_keys=True)    return "Операция успешна"def withdraw_banknote(income, old):    old_cash = {}    new_balance = []    new_cash = old    for key in new_cash:        old_cash.update(key)    if user_func.with_dict(income) is not False:        income_value = income.copy()        for key in income_value.keys():            if str(key) in old_cash.keys():                val = old_cash[str(key)]                if key in income.keys():                    new = int(val) - income[key]                    dictu = {key: new}                    if key in income:                        old_cash.pop(str(key))                        new_balance.append(dictu)        for k in new_balance:            old_cash.update(k)        return banknote_write(old_cash)    return "Не возможно выполнить операцию"def withdraw(depo):    with open("Banknote.data.json", "r", encoding="utf-8") as file:        file_content = file.read()        templates = json.loads(file_content)        a = []        banknotes = {}        for k, v in templates.items():            banknotes[int(k)] = v        bank_note = banknotes.copy()        for k, v in banknotes.items():            if v == 0:                bank_note.pop(k)        for j in bank_note.keys():            a.append(j)        a.sort(reverse=True)        m = [depo//v for v in a]        for combine in range(1, sum(m)+1):            for c in combinations_with_replacement(a, combine):                if sum(c) == depo:                    k = 0                    return c        return Falsedef new_banknote(income, old):    old_cash = {}    new_balance = []    new_cash = old    for key in new_cash:        old_cash.update(key)    income_value = income.copy()    for key in income_value.keys():        if str(key) in old_cash.keys():            val = old_cash[str(key)]            if key in income.keys():                new = income[key] + val                dictu = {key: new}                if key in income:                    old_cash.pop(str(key))                new_balance.append(dictu)    for k in new_balance:        old_cash.update(k)    return banknote_write(old_cash)
from __future__ import annotationsfrom time import sleepimport sqlite3import requestsimport datetimefrom itertools import combinations_with_replacementclass StopLoop(Exception):    passclass GeekBank:    # check tables in database    def tables(self):        try:            with sqlite3.connect('ATM.db') as db:                cursor = db.cursor()                cursor.execute("""CREATE TABLE IF NOT EXISTS users_data                            (id INTEGER, user TEXT, password INTEGER, admin                            TEXT, PRIMARY KEY("id" AUTOINCREMENT)) """)                cursor.execute('''CREATE TABLE balance (id INTEGER, user                                TEXT, balance INTEGER,                                PRIMARY KEY("id" AUTOINCREMENT))''')                cursor.execute(''' CREATE TABLE banknote ("id" INTEGER,                            "banknote" INTEGER, amount INTEGER,                            PRIMARY KEY("id" AUTOINCREMENT)) ''')                cursor.execute('''CREATE TABLE operation (id INTEGER,                            user TEXT, operation TEXT, status TEXT, amount                            INTEGER, PRIMARY KEY("id" AUTOINCREMENT))''')            return True        except sqlite3.OperationalError:            return    # restoring banknotes denominations    def restore(self):        print("After restoring the list of banknotes, "              "for full-fledged work\n"              "!!!!YOU NEED TO REPLENISH ATM!!!!")        sleep(2)        banknote_list = [1000, 500, 200, 100, 50, 20, 10]        Bureaucracy().restoring(banknote_list)        return "\nOperation successful\n"    # view all users    def _user_view(self):        user_valid = Bureaucracy().validation_check()        all_users = []        for _ in user_valid:            if ('admin', 'admin') in user_valid:                user_valid.remove(('admin', 'admin'))        for i in user_valid:            print(i[0])            all_users.append(i[0])        print()        return all_users    '''Selection of banknotes and their quantity for     withdrawing or replenishing an ATM'''    def _note_amount(self):        up_atm = {}        print(('Entry order.\n'               'On the first line - Enter the denomination of the banknote - '               'enter the denomination of the first bill.\n'               'In line - Enter the number of banknotes - '               'enter the number of bills\n'               'entered in the line - Enter the denomination of '               'the banknote -\n'               '\n'               'List of banknotes in explicit form at ATM:\n'))        print(ATM().balance_banknotes())        while True:            try:                print("To confirm or exit, enter 0\n")                banknote = abs(int(input("Enter the denomination"                                         "banknotes (integer):\n")))                if (banknote == 10 or banknote == 20 or banknote == 50 or                        banknote == 100 or banknote == 200 or                        banknote == 500 or banknote == 1000 or banknote == 0):                    if banknote != 0:                        amount = abs(int(input("Enter the number of banknotes:"                                               "(integer)\n")))                        up_atm[banknote] = amount                    else:                        return up_atm                else:                    print("Incorrect denomination of banknotes!\n"                          "Allowable denominations:\n"                          "10, 20, 50, 100, 200, 500, 1000")            except Exception:                print("Wrong number of banknotes!")class Exchange(GeekBank):    # date checking    def _validate_date(self, d: str):        try:            time_for_now = datetime.date.today()            date = datetime.datetime.strptime(d, "%d.%m.%Y").date()            if len(d) == 10 and (date <= time_for_now):                return True            else:                return False        except ValueError:            return False    # exchange rate    def _excange_req(self):        print(f"\nThe exchange rate is available for:\n"              f"USD - US dollar:     1     EUR - euro:    2\n"              f"RUR - Russian ruble: 3     BTC - bitcoin: 4\n"              f"View all available exchange rate - 5\n")        oper = int(input("Enter the operation number:\n"))        try:            response = requests.get('https://api.privatbank.ua/p24api/'                                    'pubinfo?exchange&json&coursid=11')            private_api = response.json()            if response.ok and (private_api is not []):                if oper == 1:                    for i in private_api:                        if i['ccy'] == 'USD':                            print(f"{i['ccy']}\nPurchase - "                                  f"{round(float(i['buy']), 2)} UAH\n"                                  f"Sale - {round(float(i['sale']), 2)} UAH\n")                elif oper == 2:                    for i in private_api:                        if i['ccy'] == 'EUR':                            print(f"{i['ccy']}\nPurchase - "                                  f"{round(float(i['buy']), 2)} UAH\n"                                  f"Sale - {round(float(i['sale']), 2)} UAH\n")                elif oper == 3:                    for i in private_api:                        if i['ccy'] == 'RUR':                            print(f"{i['ccy']}\nPurchase - "                                  f"{round(float(i['buy']), 2)} UAH\n"                                  f"Sale - {round(float(i['sale']), 2)} UAH\n")                elif oper == 4:                    for i in private_api:                        if i['ccy'] == 'BTC':                            print(f"{i['ccy']}\nPurchase - "                                  f"{round(float(i['buy']), 2)} USD\n"                                  f"Sale - {round(float(i['sale']), 2)} USD\n")                elif oper == 5:                    for i in private_api:                        if i['ccy'] != 'BTC':                            print(f"{i['ccy']}\nPurchase - "                                  f"{round(float(i['buy']), 2)} UAH\n"                                  f"Sale - {round(float(i['sale']), 2)} UAH\n")                        else:                            print(f"{i['ccy']}\nPurchase - "                                  f"{round(float(i['buy']), 2)} USD\n"                                  f"Sale - {round(float(i['sale']), 2)} USD\n")                else:                    print("\nWrong format!\n")        except requests.exceptions.Timeout:            print("Server not responding, please try again later")        except requests.exceptions.TooManyRedirects:            print("Possibly invalid URL")        except requests.ConnectionError:            print("No connection to server")    # view archive currency rete    def _archive_currency(self):        print(f"List of available currency codes:\n"              f"RUB CAD CNY CZK  PLN EUR GBP BYN JPY KZT MDL USD UAH \n"              f"To select a currency, enter the currency code\n")        cur_list = ['RUB', "CAD", 'CNY', 'CZK', 'PLN', 'EUR',                    'GBP', 'BYN', 'JPY', 'KZT', 'MDL', 'USD', 'UAH']        input_currency = input("Enter currency code:\n").upper()        if input_currency in cur_list:            input_date = input("Enter the date of the course in the "                               "format (01.12.2014):\n")            if self._validate_date(input_date):                time_for_now = datetime.date.today()                date = datetime.datetime.strptime(input_date,                                                  "%d.%m.%Y").date()                last_value = []                try:                    while date <= time_for_now:                        formated_day = date.strftime("%d.%m.%Y")                        url = f'https://api.privatbank.ua/p24api/exchange_' \                              f'rates?json&date={formated_day}'                        response = requests.get(url)                        dict_list = response.json()["exchangeRate"]                        if response.ok and dict_list is not []:                            for value in dict_list:                                if value.get("currency") == input_currency:                                    currensy = value.get("currency")                                    print_rate = value.get("saleRateNB")                                    print(f"{formated_day}\n"                                          f"{currensy}-{print_rate}\n")                                    last_value = []                                    last_value.append(currensy)                                    last_value.append(print_rate)                            delta = datetime.timedelta(days=1)                            date = (date + delta)                        else:                            print(f'{last_value[0]}\n'                                  f'{last_value[1]}')                        sleep(0.5)                except requests.exceptions.Timeout:                    print("Server not responding, please try again later!")                except requests.exceptions.TooManyRedirects:                    print("Possibly invalid URL")                except requests.ConnectionError:                    print("No connection to server")            else:                print("Invalid date format")        else:            print(f"Invalid currency code format")    # currency convert    def convert(self):        try:            print(f"List of available currency codes:\n"                  f"RUB CAD CNY CZK  PLN EUR GBP BYN JPY KZT MDL USD UAH \n"                  f"To select a currency, enter the currency code\n")            chek_currency = ['RUB', "CAD", 'CNY', 'CZK', 'PLN', 'EUR',                             'GBP', 'BYN', 'JPY', 'KZT', 'MDL', 'USD', 'UAH']            input_currency = input("Enter the currency you "                                   "want to convert:\n").upper()            if input_currency in chek_currency:                input_currency_value = abs(int(input(f"How much {input_currency} "                                           f"do you want to convert?\n")))                output_currency = input("Enter the currency you "                                        "want to convert to:\n").upper()                if output_currency in chek_currency:                    input_date = datetime.date.today().strftime("%d.%m.%Y")                    url = f'https://api.privatbank.ua/p24api/' \                          f'exchange_rates?json&date={input_date}'                    response = requests.get(url)                    data_dicts = response.json()['exchangeRate']                    if response.ok and (data_dicts is not []):                        first_rate = 0.0                        second_rate = 0.0                        for i in data_dicts:                            if i.get("currency") == input_currency:                                first_rate = i.get("purchaseRateNB")                        for i in data_dicts:                            if i.get("currency") == output_currency:                                second_rate = i.get("saleRateNB")                        result = round((input_currency_value * first_rate) / second_rate, 2)                        print(f"{input_currency_value}{input_currency} = {result}{output_currency}")                    else:                        print("Fail! No data found."                              "Try it in a few minutes!")                else:                    print("\nInvalid currency code\n")            else:                print("\nInvalid currency code\n")        except requests.exceptions.Timeout:            print("Server not responding, please try again later")        except requests.exceptions.TooManyRedirects:            print("Possibly invalid URL")        except requests.ConnectionError:            print("No connection to server")        except ValueError:            print("\nInvalid amount format for conversion!\n")    # menu for class Exchange    def _main_menu(self):        loop_operation = True        while loop_operation:            print(f"Exchange Rates - 1\n"                  f"Archive of exchange rates from 01.12.2014 - 2\n"                  f"Currency Converter - 3\n"                  f"Return - 0\n")            try:                operation = int(input("Enter the operation number:\n"))                if 0 <= operation <= 3:                    if operation == 1:                        self._excange_req()                    elif operation == 2:                        self._archive_currency()                    elif operation == 3:                        self.convert()                    elif operation == 0:                        loop_operation = False                else:                    print("Invalid operation!\n")            except ValueError:                print("Invalid operation!\n")            except TypeError:                print("Invalid operation!\n")        returnclass ATM(GeekBank):    # available banknotes    def remainder(self):        bank_dict = Bureaucracy().availiable_banknotes()        out_dict = {}        for keyval in bank_dict:            out_dict[keyval[0]] = keyval[1]        return out_dict    # the amount of money in the ATM    def atm_cash(self):        all_cash = []        bank = self.remainder()        banknote = bank        for line in banknote.items():            result = int(line[0]) * int(line[1])            all_cash.append(result)        return sum(all_cash)    '''Checking the availability of banknotes at the ATM,     selecting the banknotes of the required denominations'''    def _withdraw(self, depo: int):        money_count = depo        del_list = []        final_value = {}        count_loop = 7        while depo > 0:            if count_loop != 0:                try:                    take_banknotes = {}                    # Formation of a dictionary with available bills                    banknotes = Bureaucracy().banknotes_value()                    bank_note = banknotes.copy()                    for key, val in banknotes.items():                        if val == 0:                            bank_note.pop(key)                    # Formation of a list of available banknotes                    a = []                    for index in bank_note.keys():                        a.append(index)                    for i in del_list:                        a.remove(i)                    a.sort(reverse=True)                    # Cycle counter. Exiting the loop                    count_loop -= 1                    # Cycle counter. Exiting the loop                    cycles = [depo // v for v in a]                    for combine in range(1, sum(cycles) + 1):                        for combinations in \                                combinations_with_replacement(a, combine):                            # Checking denominations for availability                            if sum(combinations) == depo:                                for line in combinations:                                    take_banknotes[line] = combinations.count(line)                                for k, v in take_banknotes.items():                                    for key, val in banknotes.items():                                        if k == key and v <= val:                                            final_value[k] = v                                            break                                        elif k == key and v > val:                                            final_value[k] = val                                            del_list.append(key)                                    final_list = sum([key * value for key,                                                      value in final_value.items()])                                    depo = money_count - final_list                                    raise StopLoop                except StopLoop:                    pass            else:                return False        return final_value    '''The number of bills of each denomination and     the total amount of money in the ATM'''    def balance_banknotes(self):        all_cash = []        banknote = self.remainder()        for line in banknote.items():            result = int(line[0]) * int(line[1])            all_cash.append(result)            print(f"Denomination {line[0]} = {line[1]} bills")        return f"Banknote amount {self.atm_cash()} USD\n"    # Withdrawal of banknotes from an ATM    def withdraw_banknote(self, income: dict, old: dict):        old_cash = {}        new_balance = []        new_cash = old        for key in [new_cash]:            old_cash.update(key)            income_value = income.copy()            for key in income_value.keys():                if key in old_cash.keys():                    val = old_cash[key]                    if key in income.keys():                        new = val - income[key]                        dictu = {key: new}                        if key in income:                            old_cash.pop(key)                            new_balance.append(dictu)            for k in new_balance:                old_cash.update(k)            return Bureaucracy().banknote_write(old_cash)    # Add banknotes to ATM    def new_banknote(self, income: dict, old: dict):        old_cash = {}        new_balance = []        new_cash = old        for key in [new_cash]:            old_cash.update(key)        income_value = income.copy()        for key in income_value.keys():            if key in old_cash.keys():                val = old_cash[key]                if key in income.keys():                    new = income[key] + val                    dict_u = {key: new}                    if key in income:                        old_cash.pop(key)                    new_balance.append(dict_u)        for k in new_balance:            old_cash.update(k)        return Bureaucracy().banknote_write(old_cash)    '''Selecting the ATM update mode. Withdrawing or     replenishing an ATM. Admin menu'''    def update_atm(self, oper: int):        income = GeekBank()._note_amount()        old_cash = ATM().remainder()        if oper == 2:            new_balance = ATM().withdraw_banknote(income, old_cash)        else:            new_balance = ATM().new_banknote(income, old_cash)        return new_balance    # Add user account    def add_user(self):        try:            print("\nCreate a new account!\n")            name = input("Enter the name of the new user:\n")            password = input("Enter new user password:\n")            administr = input("Accessing the admin menu(True or False):\n")            balance = int(input("The amount of the balance "                                "of the new user\n"))            print(Bureaucracy().new_acount(name, password,                                           administr, balance))        except ValueError:            print("\nInvalid input!!!\n")            return "\nInvalid operation!\n"'''class for reading and writing data to the database'''class Bureaucracy(GeekBank):    # Account validation at login    def validation_check(self):        with sqlite3.connect('ATM.db') as db:            cursor = db.cursor()            valid = cursor.execute("SELECT user, password, "                                   "admin FROM users_data").fetchall()            return valid    # check account balance    def check_balance(self, name: str):        # Balance checking        with sqlite3.connect('ATM.db') as db:            cursor = db.cursor()            balance = cursor.execute("SELECT balance FROM balance "                                     "WHERE user == ?", (name,)).fetchone()            return balance    # banknote value restoring    def restoring(self, banknote_list: list):        # Banknotes restoring        with sqlite3.connect('ATM.db') as db:            cursor = db.cursor()            for i in banknote_list:                cursor.execute("""INSERT INTO banknote                (banknote, amount) VALUES(?, ?)""", (i, 0))        return "\nOperation successful\n"    # amount cash in atm    def banknotes_value(self):        with sqlite3.connect('ATM.db') as db:            cursor = db.cursor()            bank_dict = cursor.execute("SELECT banknote, "                                       "amount FROM banknote").fetchall()            output_dict = {}            for keyval in bank_dict:                output_dict[keyval[0]] = keyval[1]            return output_dict    # operation denied record    def operation_denied(self, name: str, depo: int):        with sqlite3.connect('ATM.db') as db:            cursor = db.cursor()            cursor.execute("""INSERT INTO operation (user, operation,                            status, amount) VALUES(?, ?, ?, ?)""",                           (name, 'withdraw', 'denied', depo))    ''' A record of the successful completion of the operation to     withdraw money from the account '''    def operation_succes(self, new_balance: int, name: str, depo: int):        with sqlite3.connect('ATM.db') as db:            cursor = db.cursor()            cursor.execute("UPDATE balance SET balance == ? WHERE user == ?",                           (new_balance, name,)).fetchone()            cursor.execute("""INSERT INTO operation (user, operation,                            status, amount) VALUES(?, ?, ?, ?)""",                           (name, 'withdraw', 'success', depo))    # Balance recording after replenishment    def deposite_money(self, new_balance: int, name: str, depo: int):        with sqlite3.connect('ATM.db') as db:            cursor = db.cursor()            cursor.execute("UPDATE balance SET balance == ? WHERE user == ?",                           (new_balance, name,)).fetchone()            cursor.execute("""INSERT INTO operation (user, operation,                            status, amount) VALUES(?, ?, ?, ?)""",                           (name, 'deposite', 'success', depo))    # account change pin    def change_pin(self, name: str, pin: str):        with sqlite3.connect('ATM.db') as db:            cursor = db.cursor()            cursor.execute("UPDATE users_data SET password == ? "                           "WHERE user == ?",                           (str(pin), name,)).fetchone()    # write banknotes into database    def banknote_write(self, new: dict):        # write banknotes in database        with sqlite3.connect('ATM.db') as db:            write_dict = []            for k, v in new.items():                write_dict.append({k: v})            for d in write_dict:                for key, val in d.items():                    cursor = db.cursor()                    cursor.execute("UPDATE banknote SET amount == ? "                                   "WHERE banknote == ?",                                   (val, key,)).fetchone()        return "Operation successful"    # available banknote    def availiable_banknotes(self):        with sqlite3.connect('ATM.db') as db:            cursor = db.cursor()            banknotes_value = cursor.execute("SELECT banknote, amount"                                             " FROM banknote").fetchall()            return banknotes_value    # create new account    def new_acount(self, name: str, password: str, adminisr: str, balance: int):        with sqlite3.connect('ATM.db') as db:            cursor = db.cursor()            valid = cursor.execute("SELECT user "                                   "FROM users_data").fetchall()            if (name,) not in valid:                cursor.execute("""INSERT INTO users_data                (user, password, admin) VALUES( ?, ?, ?)""",                               (name, password, adminisr))            cursor.execute("""INSERT INTO balance            (user, balance) VALUES(?, ?)""", (name, balance))            return "Operation successful"    # check for available users    def user_check(self):        with sqlite3.connect('ATM.db') as db:            cursor = db.cursor()            cursor.execute("""SELECT user FROM users_data""")            if cursor.fetchone() is None:                print("Restore. Add new account")                return ATM().add_user()        return "There are registered users"class Authorization:    __table_check = GeekBank().tables()    __user_check = Bureaucracy().user_check()    # user verification    def validator(self, name: str, pin: str):        GeekBank().tables()        print("\nAUTHORIZATION\n")        valid = Bureaucracy().validation_check()        if (name, pin, 'False') in valid:            sleep(0.3)            return User(name, pin)        elif (name, pin, 'True') in valid:            sleep(0.3)            return Collector(name, pin)        print(f"Invalid username or password!\n")        return Noneclass Person:    def __init__(self, name: str, pin: str):        self.name = name        self.__pin = pin        print("*** Welcome GeekHub-Bank ***")    # person balance    def balance(self, person: User):        name = person.name        user_balance = Bureaucracy().check_balance(name)        balance = 0        for row in user_balance:            balance = int(row)        return balance    # change person pin    def change_pin(self, name: str):        new_pin1 = input("Insert new pin:")        new_pin2 = input("Insert new pin one more time:")        if new_pin1 == new_pin2:            Bureaucracy().change_pin(name, new_pin2)        else:            print("Incorrect value")    # money transfer to another person    def money_transfer(self, person: User | Collector):        name = person.name        my_balance = person.balance(person)        valid = GeekBank()._user_view()        transfer_amount = abs(int(input("Enter the amount to transfer:\n")))        name_to_transfer = input("Enter client name:\n")        new_balance = my_balance - transfer_amount        if (transfer_amount < my_balance) and \                ((my_balance + transfer_amount) > 0) and \                name_to_transfer in valid:            Bureaucracy().operation_succes(new_balance, name,                                           transfer_amount)            client_balance = person.balance(person)            new_client_balance = client_balance + transfer_amount            Bureaucracy().deposite_money(new_client_balance,                                         name_to_transfer,                                         transfer_amount)            print(f"{name}, You have transferred from your account "                  f"{transfer_amount}, in your account "                  f"{person.balance(person)} USD!\n")        else:            print("\nInvalid operation\n")    # user account replenishment    def deposite(self, person: User | Collector):        name = person.name        my_balance = person.balance(person)        depo = abs(int(input("Enter the investment amount:\n")))        new_balance = my_balance + depo        Bureaucracy().deposite_money(new_balance, name, depo)        return depo, new_balance    # withdrawal Cash    def withdraw_cash(self, person: User | Collector):        name = person.name        my_balance = person.balance(person)        money = abs(int(input("Enter the amount to withdraw:\n")))        if money < my_balance and (my_balance + money) > 0:            if ATM().atm_cash() >= money:                some_val = ATM()._withdraw(money)                if some_val is not False:                    print(f"Banknotes issued:")                    for k, v in some_val.items():                        print(f"{k} - {v}")                    print()                    ATM().withdraw_banknote(some_val, ATM().remainder())                    new_balance = my_balance - money                    Bureaucracy().operation_succes(new_balance,                                                   name, money)                    return money, new_balance                else:                    print(f"ATM cannot dispense the selected amount\n"                          f"Choose from the available denominations\n"                          f"{ATM().balance_banknotes()}")                    Bureaucracy().operation_denied(name, money)            else:                print(f"ATM cannot dispense the selected amount\n"                      f"Not enough money in the ATM!")                Bureaucracy().operation_denied(name, money)        else:            print(f"Not enough money in the account!\n"                  f"in your account {person.balance(person)}")            Bureaucracy().operation_denied(name, money)            return Falseclass User(Person):    def user_menu(self):        Menu().user_menu(self)class Collector(Person):    def admin_menu(self):        Menu().admin_menu(self)    def user_menu(self):        Menu().user_menu(self)class Menu:    def user_menu(self, person: User | Collector):        name = person.name        while True:            try:                print("Choose an operation:\n"                      "To view the balance, click - 1\n"                      "To withdraw money, click - 2\n"                      "To top up your account, click - 3\n"                      "Currency rates and currency converter, click - 4\n"                      "Money transfer, click - 5\n"                      "Change pin, click - 6\n"                      "To exit, press - 0\n")                operation_num = int(input("Enter the operation number:\n"))                if 0 <= operation_num <= 6:                    if operation_num == 1:                        sleep(0.3)                        print(f"{name} in your account "                              f"{person.balance(person)} USD!\n")                    elif operation_num == 2:                        sleep(0.3)                        raw = person.withdraw_cash(person)                        if not raw:                            pass                        else:                            print(f"{name} You have withdrawn from the account "                                  f"{raw[0]}, on the account "                                  f"{person.balance(person)} "                                  f"USD!\n")                    elif operation_num == 3:                        sleep(0.3)                        raw = person.deposite(person)                        print(f"{name} You have deposited {raw[0]}, on the "                              f"account {person.balance(person)} "                              f"USD!\n")                    elif operation_num == 4:                        sleep(0.3)                        print(Exchange()._main_menu())                    elif operation_num == 5:                        sleep(0.3)                        person.money_transfer(person)                    elif operation_num == 6:                        sleep(0.3)                        person.change_pin(name)                    elif operation_num == 0:                        break                else:                    sleep(0.3)                    print("Invalid operation!\n")            except Exception:                print("Invalid operation!\n")    def admin_menu(self, person: Collector):        name = person.name        while True:            try:                print("Choose an operation:\n"                      "To view the number of bills, click - 1\n"                      "Change the number of bills, click - 2\n"                      "Recovery menu, click - 3 \n"                      "User menu, click - 4 \n"                      "Finish work with ATM, click - 0\n")                operation_num = int(input("Enter the operation number:\n"))                if 0 <= operation_num <= 4:                    if operation_num == 1:                        sleep(0.3)                        print(Bureaucracy().banknotes_value())                    elif operation_num == 2:                        print("Choose an operation:\n"                              "Add bills, click - 1\n"                              "Withdraw bills, click - 2\n")                        operation = int(input("Enter the operation "                                              "number:\n"))                        if operation == 1:                            sleep(0.3)                            print(ATM().update_atm(operation))                        elif operation == 2:                            sleep(0.3)                            print(ATM().update_atm(operation))                        else:                            sleep(0.3)                            print("Incorrect operation!\n")                    elif operation_num == 3:                        print("Choose an operation:\n"                              "Add users - 1\n"                              "View users - 2\n"                              "Restore the list of banknotes - 3\n")                        operation = int(input("Enter the operation "                                              "number:\n"))                        if 0 <= operation <= 4:                            if operation == 1:                                sleep(0.3)                                print(ATM().add_user())                            elif operation == 2:                                sleep(0.3)                                GeekBank()._user_view()                            elif operation == 3:                                sleep(0.3)                                print(GeekBank().restore())                            else:                                sleep(0.3)                                print("Incorrect operation!\n")                    elif operation_num == 4:                        sleep(0.3)                        person.user_menu()                    elif operation_num == 0:                        sleep(0.3)                        break                    else:                        sleep(0.3)                        print("Incorrect operation!\n")                        pass            except ValueError:                print("Invalid input!!!\n")authorize = Authorization()admin = authorize.validator('admin', 'admin')admin.admin_menu()anna = authorize.validator('user', '1111')print(admin.__dir__())print(anna.__dir__())#nobody = authorize.validator('stepan', '1111')#nobody.balance(nobody)